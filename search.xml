<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sql入门(4)--算术运算符和比较运算符</title>
      <link href="/2019/12/31/MYSQL/sql%E5%85%A5%E9%97%A8(4)--%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2019/12/31/MYSQL/sql%E5%85%A5%E9%97%A8(4)--%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1 算术运算符"></a>1 算术运算符</h2><p>在SELECT子句中可以使用常数或表达式<br>算术运算符:四则运算 <strong>+   -  *  /</strong></p><blockquote><p>Example:</p></blockquote><pre><code>mysql&gt; SELECT product_name, sale_price,    -&gt;        sale_price * 2 AS &quot;sale_price_x2&quot;    -&gt;   FROM Product;+--------------+------------+---------------+| product_name | sale_price | sale_price_x2 |+--------------+------------+---------------+| T恤          |       1000 |          2000 || 打孔器       |        500 |          1000 || 运动T恤      |       4000 |          8000 || 菜刀         |       3000 |          6000 || 高压锅       |       6800 |         13600 || 叉子         |        500 |          1000 || 擦菜板       |        880 |          1760 || 圆珠笔       |        100 |           200 |+--------------+------------+---------------+8 rows in set (0.03 sec)</code></pre><blockquote><p>Note:<br>1 可以使用()来改变运算优先级<br>2 包含NULL的计算,结果肯定是NULL</p></blockquote><h2 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2 比较运算符"></a>2 比较运算符</h2><p>在WHERE子句中可以使用比较运算符进行复杂的条件筛选,组合出各种各样的条件表达式</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;&gt;</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr></tbody></table><p><br></p><blockquote><p>等号与不等号</p></blockquote><pre><code>mysql&gt; SELECT product_name, product_type    -&gt;   FROM Product    -&gt;  WHERE sale_price = 500;+--------------+--------------+| product_name | product_type |+--------------+--------------+| 打孔器       | 办公用品     || 叉子         | 厨房用具     |+--------------+--------------+2 rows in set (0.00 sec)mysql&gt; SELECT product_name, product_type    -&gt;   FROM Product    -&gt;  WHERE sale_price &lt;&gt; 500;+--------------+--------------+| product_name | product_type |+--------------+--------------+| T恤          | 衣服         || 运动T恤      | 衣服         || 菜刀         | 厨房用具     || 高压锅       | 厨房用具     || 擦菜板       | 厨房用具     || 圆珠笔       | 办公用品     |+--------------+--------------+6 rows in set (0.00 sec)</code></pre><p><br></p><blockquote><p>大于等于号</p></blockquote><pre><code>mysql&gt; SELECT product_name, product_type, sale_price    -&gt;   FROM Product    -&gt;  WHERE sale_price &gt;= 1000;+--------------+--------------+------------+| product_name | product_type | sale_price |+--------------+--------------+------------+| T恤          | 衣服         |       1000 || 运动T恤      | 衣服         |       4000 || 菜刀         | 厨房用具     |       3000 || 高压锅       | 厨房用具     |       6800 |+--------------+--------------+------------+4 rows in set (0.00 sec)</code></pre><p><br></p><blockquote><p>日期也可以使用比较运算符</p></blockquote><pre><code>mysql&gt; SELECT product_name, product_type, regist_date    -&gt;   FROM Product    -&gt;  WHERE regist_date &lt; &#39;2009-09-27&#39;;+--------------+--------------+-------------+| product_name | product_type | regist_date |+--------------+--------------+-------------+| T恤          | 衣服         | 2009-09-20  || 打孔器       | 办公用品     | 2009-09-11  || 菜刀         | 厨房用具     | 2009-09-20  || 高压锅       | 厨房用具     | 2009-01-15  || 叉子         | 厨房用具     | 2009-09-20  || 擦菜板       | 厨房用具     | 2008-04-28  |+--------------+--------------+-------------+6 rows in set (0.01 sec)</code></pre><p><br></p><blockquote><p>多列运算</p></blockquote><p>筛选出 售价大于进货价500元以上的商品</p><pre><code>mysql&gt; SELECT product_name, sale_price, purchase_price    -&gt;   FROM Product    -&gt;  WHERE sale_price - purchase_price &gt;= 500;+--------------+------------+----------------+| product_name | sale_price | purchase_price |+--------------+------------+----------------+| T恤          |       1000 |            500 || 运动T恤      |       4000 |           2800 || 高压锅       |       6800 |           5000 |+--------------+------------+----------------+3 rows in set (0.01 sec)</code></pre><p><br></p><blockquote><p>Note:<br>1 对字符串类型使用比较运算符,使用的是和数字比较不同的规则.典型的规则就是按照字典顺序进行比较<br>2 不可以对NULL使用比较运算符</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SELECT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性模型--最小二乘回归--数理推导</title>
      <link href="/2019/12/30/Machine-Learning/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B--%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%9B%9E%E5%BD%92--%E6%95%B0%E7%90%86%E6%8E%A8%E5%AF%BC/"/>
      <url>/2019/12/30/Machine-Learning/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B--%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%9B%9E%E5%BD%92--%E6%95%B0%E7%90%86%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="线性模型–最小二乘回归–数理推导"><a href="#线性模型–最小二乘回归–数理推导" class="headerlink" title="线性模型–最小二乘回归–数理推导"></a>线性模型–最小二乘回归–数理推导</h1><hr><h2 id="1-最小二乘线性回归模型"><a href="#1-最小二乘线性回归模型" class="headerlink" title="1 最小二乘线性回归模型"></a>1 最小二乘线性回归模型</h2><p>$$ \mathrm{y}_{i}=\omega_{1} x_{i 1}+\omega_{2} x_{i 2}+\ldots \omega_{d} x_{i d}+b $$</p><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><ul><li>参数说明</li></ul><p>$$\hat{\omega}=(\omega ; b)=\left(\begin{array}{c}<br>{\omega_{1}} \\<br>{\omega_{2}} \\<br>{\ldots} \\<br>{\omega_{d}} \\<br>{b}<br>\end{array}\right)  $$<br>$$ \mathbf{X}=\left(\begin{array}{ccccc}<br>{x_{11}} &amp; {x_{12}} &amp; {\dots} &amp; {x_{1 d}} &amp; {1} \\<br>{x_{21}} &amp; {x_{22}} &amp; {\dots} &amp; {x_{2 d}} &amp; {1} \\<br>{\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} &amp; {\vdots} \\<br>{x_{m 1}} &amp; {x_{m 2}} &amp; {\dots} &amp; {x_{m d}} &amp; {1}<br>\end{array}\right)=\left(\begin{array}{cc}<br>{x_{1}^{\mathrm{T}}} &amp; {1} \\<br>{x_{2}^{\mathrm{T}}} &amp; {1} \\<br>{\vdots} &amp; {\vdots} \\<br>{x_{m}^{\mathrm{T}}} &amp; {1}<br>\end{array}\right) $$</p><p><br></p><ul><li>损失函数(均方误差)</li></ul><p>$$ \hat{\boldsymbol{w}}^{*}=\underset{\hat{\boldsymbol{w}}}{\arg \min }(\boldsymbol{y}-\mathbf{X} \hat{\boldsymbol{w}})^{\mathrm{T}}(\boldsymbol{y}-\mathbf{X} \hat{\boldsymbol{w}}) $$</p><p>令</p><p>$$ E_{\hat{\boldsymbol{w}}}=(\boldsymbol{y}-\mathbf{X} \hat{\boldsymbol{w}})^{\mathrm{T}}(\boldsymbol{y}-\mathbf{X} \hat{\boldsymbol{w}}) $$</p><p>求导数得</p><p>$$ \begin{aligned}<br>&amp;\frac{\partial E_{\hat{w}}}{\partial \hat{w}}=2 \mathbf{X}^{\mathrm{T}}(\mathbf{X} \hat{w}-\boldsymbol{y})\\<br>&amp;\hat{\boldsymbol{w}}^{*}=\left(\mathbf{X}^{\mathrm{T}} \mathbf{X}\right)^{-1} \mathbf{X}^{\mathrm{T}} \boldsymbol{y}<br>\end{aligned} $$</p><ul><li>解得</li></ul><p>$$ f\left(\hat{\boldsymbol{x}}_{i}\right)=\hat{\boldsymbol{x}}_{i}^{\mathrm{T}}\left(\mathbf{X}^{\mathrm{T}} \mathbf{X}\right)^{-1} \mathbf{X}^{\mathrm{T}} \boldsymbol{y} $$</p><hr><h2 id="2-广义线性模型"><a href="#2-广义线性模型" class="headerlink" title="2 广义线性模型"></a>2 广义线性模型</h2><p>$$ y=g^{-1}\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b\right) $$</p><p>如图所示 (对数线性回归)<br>$$<br>y=e^{w^{\mathrm{T}} x+b}<br>$$</p><p><img src="https://cdn.mathpix.com/snip/images/ncu3zut9mNJG899sf9UOmf_U5qOZBksm7yNChGxSbU4.original.fullsize.png" alt="对数线性回归"></p><blockquote><p>Note:<br>1 联系函数$ g() $(link function) 单调可微<br>2 所有广义线性模型都可以化作简单线性模型求解</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性模型 </tag>
            
            <tag> Scikit-Learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性模型--最小二乘回归--Scikit_Learn实现</title>
      <link href="/2019/12/30/Machine-Learning/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B--%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%9B%9E%E5%BD%92--Scikit_Learn%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/12/30/Machine-Learning/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B--%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%9B%9E%E5%BD%92--Scikit_Learn%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>#线性模型–最小二乘回归–Scikit-Learn实现</p><h2 id="1-线性回归模型"><a href="#1-线性回归模型" class="headerlink" title="1 线性回归模型"></a>1 线性回归模型</h2><p>$$ \mathrm{y}_{i}=\omega_{1} x_{i 1}+\omega_{2} x_{i 2}+\ldots \omega_{d} x_{i d}+b $$</p><hr><h2 id="2-核心代码"><a href="#2-核心代码" class="headerlink" title="2  核心代码"></a>2  核心代码</h2><pre><code class="python">from sklearn import linear_modelLR = linear_model.LinearRegression() #设定模型LR.fit(X_train, y_train) #拟合模型y_pred = LR.predict(X_test) #模型预测LR.coef_ #线性模型系数LR.intercept_ #线性模型截距项LR.rank_ #训练集X矩阵的秩LR.singular_ #X的奇异值LR.score(X_train, y_train) #模型得分LR.get_params() #模型参数</code></pre><hr><h2 id="3-Example"><a href="#3-Example" class="headerlink" title="3 Example"></a>3 Example</h2><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npfrom sklearn import datasets, linear_modelfrom sklearn.metrics import mean_squared_error, r2_score</code></pre><pre><code class="python">#从datasets中导入diabetes数据# Load the diabetes datasetdiabetes_X, diabetes_y = datasets.load_diabetes(return_X_y=True)# Use only one featurediabetes_X = diabetes_X[:, np.newaxis, 2]# Split the data into training/testing setsdiabetes_X_train = diabetes_X[:-20]diabetes_X_test = diabetes_X[-20:]# Split the targets into training/testing setsdiabetes_y_train = diabetes_y[:-20]diabetes_y_test = diabetes_y[-20:]</code></pre><pre><code class="python"># Create linear regression objectregr = linear_model.LinearRegression()# Train the model using the training setsregr.fit(diabetes_X_train, diabetes_y_train)# Make predictions using the testing setdiabetes_y_pred = regr.predict(diabetes_X_test)# The coefficientsprint(&#39;Coefficients: \n&#39;, regr.coef_)# The Interceptprint(&#39;Intercept: \n&#39;, regr.intercept_)# The mean squared errorprint(&#39;Mean squared error: %.2f&#39;      % mean_squared_error(diabetes_y_test, diabetes_y_pred))# regr.scoreprint(&#39;Coefficient of training: %.2f&#39;      % regr.score(diabetes_X_train, diabetes_y_train))# The coefficient of determination: 1 is perfect predictionprint(&#39;Coefficient of determination: %.2f&#39;      % r2_score(diabetes_y_test, diabetes_y_pred))# regr.get_paramsprint(&#39;Parameters: \n&#39;, regr.get_params())</code></pre><pre><code>Coefficients:  [938.23786125]Intercept:  152.91886182616167Mean squared error: 2548.07Coefficient of training: 0.34Coefficient of determination: 0.47Parameters:  {&#39;copy_X&#39;: True, &#39;fit_intercept&#39;: True, &#39;n_jobs&#39;: None, &#39;normalize&#39;: False}</code></pre><pre><code class="python"># Plot outputsplt.scatter(diabetes_X_test, diabetes_y_test,  color=&#39;black&#39;)plt.plot(diabetes_X_test, diabetes_y_pred, color=&#39;blue&#39;, linewidth=3)plt.xticks(())plt.yticks(())plt.show()</code></pre><p><img src="https://cdn.mathpix.com/snip/images/NnwGlWW21rIyRWxM6t6TZ0JnGlQE5CUvKe0Y-RocKYM.original.fullsize.png" alt></p><hr><h2 id="4-sklearn-linear-model详解"><a href="#4-sklearn-linear-model详解" class="headerlink" title="4 sklearn.linear_model详解"></a>4 sklearn.linear_model详解</h2><pre><code>class sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=None)</code></pre><ul><li>Parameters</li></ul><blockquote><p><strong>fit_intercept</strong> : bool, optional, default True<br>Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).<br>是否拟合截距项</p></blockquote><blockquote><p><strong>normalize bool</strong> : optional, default False<br>This parameter is ignored when fit_intercept is set to False. If True, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use sklearn.preprocessing.StandardScaler before calling fit on an estimator with normalize=False.<br>是否拟合前进行数据标准化</p></blockquote><blockquote><p><strong>copy_X</strong> : bool , optional, default True<br>If True, X will be copied; else, it may be overwritten.<br>如果为True，将复制X；否则为X。 否则，它可能会被覆盖。</p></blockquote><blockquote><p><strong>n_jobs</strong> : int or None, optional (default=None)<br>The number of jobs to use for the computation. This will only provide speedup for n_targets &gt; 1 and sufficient large problems. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.<br>用于计算的处理器数。 这只会为n_targets&gt; 1和足够大的问题提供加速。 除非在joblib.parallel_backend上下文中，否则None表示1。 -1表示使用所有处理器。</p></blockquote><p><br></p><ul><li>Attributes</li></ul><blockquote><p><strong>coef_</strong> : array of shape (n_features, ) or (n_targets, n_features)<br>Estimated coefficients for the linear regression problem. If multiple targets are passed during the fit (y 2D), this is a 2D array of shape (n_targets, n_features), while if only one target is passed, this is a 1D array of length n_features.<br>线性回归问题的估计系数</p></blockquote><blockquote><p><strong>rank_</strong> ; int<br>Rank of matrix X. Only available when X is dense.<br>矩阵X的秩,仅当X密集时可用</p></blockquote><blockquote><p><strong>singular_</strong> : array of shape (min(X, y),)<br>Singular values of X. Only available when X is dense.<br>X的奇异值,仅当X密集时可用</p></blockquote><blockquote><p><strong>intercept_</strong> float or array of shape of (n_targets,)<br>Independent term in the linear model. Set to 0.0 if fit_intercept = False.<br>线性模型中的截距项</p></blockquote><ul><li>Methods</li></ul><blockquote><p>fit(self, X, y[, sample_weight])<br>Fit linear model.<br>拟合模型</p></blockquote><blockquote><p> get_params(self[, deep])<br>Get parameters for this estimator.<br>获得模型参数</p></blockquote><blockquote><p>predict(self, X)<br>Predict using the linear model.<br>利用训练模型预测</p></blockquote><blockquote><p>score(self, X, y[, sample_weight])<br>Return the coefficient of determination R^2 of the prediction.<br>模型得分,取值范围[0,1],1最好</p></blockquote><blockquote><p>set_params(self, **params)<br>Set the parameters of this estimator.<br>为模型设定参数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性模型 </tag>
            
            <tag> Scikit-Learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL文章索引</title>
      <link href="/2019/12/29/MYSQL/SQL_Catelogue/"/>
      <url>/2019/12/29/MYSQL/SQL_Catelogue/</url>
      
        <content type="html"><![CDATA[<ol><li>SQL入门(1)–SQL了解</li><li>SQL入门(2)–表的创建</li><li>SQL入门(3)–SELECT语句基础</li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql入门(3)--SELECT语句基础</title>
      <link href="/2019/12/29/MYSQL/sql%E5%85%A5%E9%97%A8(3)--SELECT%E8%AF%AD%E5%8F%A5%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/29/MYSQL/sql%E5%85%A5%E9%97%A8(3)--SELECT%E8%AF%AD%E5%8F%A5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="SELECT语句基础"><a href="#SELECT语句基础" class="headerlink" title="SELECT语句基础"></a>SELECT语句基础</h1><h2 id="1-列的查询"><a href="#1-列的查询" class="headerlink" title="1 列的查询"></a>1 列的查询</h2><ul><li><p><strong>SELECT语句</strong>:只从表中选出必要数据,SELECT语句是SQL语句中使用最多的最基本的SQL语句</p></li><li><p><strong>匹配查询</strong>:通过SELECT语句查询并选取出必要的数据过程成为匹配查询或查询(query)</p></li></ul><h3 id="1-1-SELECT语句的基本语法"><a href="#1-1-SELECT语句的基本语法" class="headerlink" title="1.1 SELECT语句的基本语法"></a>1.1 SELECT语句的基本语法</h3><pre><code>SELECT &lt;列名&gt;,.... FROM &lt;表名&gt;;</code></pre><p>该SELECT语句包含了SELECT和FROM两个子句(clause).SELECT子句中列举了希望从表中查询出的列的名称,而FROM子句则指定了选取出数据的表的名称</p><ul><li>Example:</li></ul><pre><code>mysql&gt; SELECT product_id, product_name, purchase_price    -&gt;  FROM product;+------------+--------------+----------------+| product_id | product_name | purchase_price |+------------+--------------+----------------+| 0001       | T恤          |            500 || 0002       | 打孔器       |            320 || 0003       | 运动T恤      |           2800 || 0004       | 菜刀         |           2800 || 0005       | 高压锅       |           5000 || 0006       | 叉子         |           NULL || 0007       | 擦菜板       |            790 || 0008       | 圆珠笔       |           NULL |+------------+--------------+----------------+8 rows in set (0.00 sec)</code></pre><hr><h3 id="1-2-查询所有列"><a href="#1-2-查询所有列" class="headerlink" title="1.2 查询所有列"></a>1.2 查询所有列</h3><pre><code>SELECT * FROM &lt;表名&gt;;</code></pre><ul><li>Example</li></ul><pre><code>mysql&gt; SELECT *    -&gt; FROM product;+------------+--------------+--------------+------------+----------------+-------------+| product_id | product_name | product_type | sale_price | purchase_price | regist_date |+------------+--------------+--------------+------------+----------------+-------------+| 0001       | T恤          | 衣服         |       1000 |            500 | 2009-09-20  || 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  || 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        || 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  || 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  || 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  || 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  || 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |+------------+--------------+--------------+------------+----------------+-------------+8 rows in set (0.00 sec)</code></pre><blockquote><p>Note:<br>用 SELECT *的话的列将按照TABLE中的定义顺序输出</p></blockquote><hr><h3 id="1-3-为列设定别名"><a href="#1-3-为列设定别名" class="headerlink" title="1.3 为列设定别名"></a>1.3 为列设定别名</h3><p>使用别名可以让SELECT语句的执行结果更加容易理解和操作</p><ul><li>SELECT-AS基本语法</li></ul><pre><code>SELECT &lt;列名1&gt; AS &lt;别名1&gt;,       &lt;列名2&gt; AS &lt;别名2&gt;,       &lt;列名3&gt; AS &lt;别名3&gt;,       .... FROM &lt;表名&gt;;</code></pre><blockquote><p>Note:<br>如果使用中文别名记得加入双引号””</p></blockquote><ul><li>Example</li></ul><pre><code>mysql&gt; SELECT product_id     AS id,    -&gt;        product_name   AS &quot;商品名称&quot;,    -&gt;        purchase_price AS &quot;进货单价&quot;    -&gt;   FROM Product;+------+--------------+--------------+| id   | 商品名称     | 进货单价     |+------+--------------+--------------+| 0001 | T恤          |          500 || 0002 | 打孔器       |          320 || 0003 | 运动T恤      |         2800 || 0004 | 菜刀         |         2800 || 0005 | 高压锅       |         5000 || 0006 | 叉子         |         NULL || 0007 | 擦菜板       |          790 || 0008 | 圆珠笔       |         NULL |+------+--------------+--------------+8 rows in set (0.00 sec)</code></pre><hr><h3 id="1-4-SELECT常数的查询"><a href="#1-4-SELECT常数的查询" class="headerlink" title="1.4 SELECT常数的查询"></a>1.4 SELECT常数的查询</h3><p>SELECT子句中不仅可以书写别名,还可以书写常数</p><ul><li>Example</li></ul><pre><code>mysql&gt; SELECT &#39;商品&#39; AS string, 38 AS number, &#39;2009-02-24&#39; AS date,    -&gt;        product_id, product_name    -&gt;   FROM Product;+--------+--------+------------+------------+--------------+| string | number | date       | product_id | product_name |+--------+--------+------------+------------+--------------+| 商品   |     38 | 2009-02-24 | 0001       | T恤          || 商品   |     38 | 2009-02-24 | 0002       | 打孔器       || 商品   |     38 | 2009-02-24 | 0003       | 运动T恤      || 商品   |     38 | 2009-02-24 | 0004       | 菜刀         || 商品   |     38 | 2009-02-24 | 0005       | 高压锅       || 商品   |     38 | 2009-02-24 | 0006       | 叉子         || 商品   |     38 | 2009-02-24 | 0007       | 擦菜板       || 商品   |     38 | 2009-02-24 | 0008       | 圆珠笔       |+--------+--------+------------+------------+--------------+8 rows in set (0.00 sec)</code></pre><p>product_id, product_name是原有的,而string,number,data是原来没有的常数列</p><hr><h2 id="2-从结果中删除重复行"><a href="#2-从结果中删除重复行" class="headerlink" title="2 从结果中删除重复行"></a>2 从结果中删除重复行</h2><ul><li><p><strong>DISTINCT</strong>:想要通过删除重复行时,可以通过在SELECT子句中使用DISTINCT来实现<br><br></p></li><li><p>SELECT-DISTINCT基本语法</p><pre><code>SELECT DISTIN &lt;列名&gt;FROM &lt;表名&gt;;</code></pre></li><li><p>Example</p></li></ul><pre><code>mysql&gt; SELECT product_type    -&gt;   FROM Product;+--------------+| product_type |+--------------+| 衣服         || 办公用品     || 衣服         || 厨房用具     || 厨房用具     || 厨房用具     || 厨房用具     || 办公用品     |+--------------+8 rows in set (0.00 sec)mysql&gt; SELECT DISTINCT product_type    -&gt;   FROM Product;+--------------+| product_type |+--------------+| 衣服         || 办公用品     || 厨房用具     |+--------------+3 rows in set (0.00 sec)</code></pre><hr><blockquote><p>Note:<br>在使用DISTINCT时候NULL数据会被合并为一项</p></blockquote><ul><li>Example</li></ul><pre><code>mysql&gt; SELECT purchase_price    -&gt;   FROM Product;+----------------+| purchase_price |+----------------+|            500 ||            320 ||           2800 ||           2800 ||           5000 ||           NULL ||            790 ||           NULL |+----------------+8 rows in set (0.00 sec)mysql&gt; SELECT DISTINCT purchase_price    -&gt;   FROM Product;+----------------+| purchase_price |+----------------+|            500 ||            320 ||           2800 ||           5000 ||           NULL ||            790 |+----------------+6 rows in set (0.00 sec)</code></pre><hr><blockquote><p>Note:<br>DISTINCT也可以多列使用</p></blockquote><ul><li>Example</li></ul><pre><code>mysql&gt; SELECT DISTINCT product_type, regist_date    -&gt;   FROM Product;+--------------+-------------+| product_type | regist_date |+--------------+-------------+| 衣服         | 2009-09-20  || 办公用品     | 2009-09-11  || 衣服         | NULL        || 厨房用具     | 2009-09-20  || 厨房用具     | 2009-01-15  || 厨房用具     | 2008-04-28  || 办公用品     | 2009-11-11  |+--------------+-------------+7 rows in set (0.00 sec)</code></pre><hr><h2 id="3-SELECT的WHERE筛选"><a href="#3-SELECT的WHERE筛选" class="headerlink" title="3 SELECT的WHERE筛选"></a>3 SELECT的WHERE筛选</h2><ul><li><p><strong>WHERE</strong>:SELECT语句可以统计WHERE子句来指定查询数据的条件</p></li><li><p>SELECT-WHERE基本语法</p></li></ul><pre><code>SELECT &lt;列名&gt;,....  FROM &lt;表名&gt;  WHERE &lt;条件表达式&gt;,...;</code></pre><ul><li>Example</li></ul><pre><code>mysql&gt; SELECT product_name, product_type    -&gt;   FROM Product    -&gt;  WHERE product_type = &#39;衣服&#39;;+--------------+--------------+| product_name | product_type |+--------------+--------------+| T恤          | 衣服         || 运动T恤      | 衣服         |+--------------+--------------+2 rows in set (0.01 sec)</code></pre><hr><blockquote><p>Note<br>作为查询条件的列可以不输出</p></blockquote><ul><li>Example</li></ul><pre><code>mysql&gt; SELECT product_name    -&gt;   FROM Product    -&gt;  WHERE product_type = &#39;衣服&#39;;+--------------+| product_name |+--------------+| T恤          || 运动T恤      |+--------------+2 rows in set (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SELECT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql入门(2)--表的创建</title>
      <link href="/2019/12/29/MYSQL/sql%E5%85%A5%E9%97%A8(2)--%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2019/12/29/MYSQL/sql%E5%85%A5%E9%97%A8(2)--%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库与表的创建"><a href="#数据库与表的创建" class="headerlink" title="数据库与表的创建"></a>数据库与表的创建</h1><hr><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1 创建数据库"></a>1 创建数据库</h2><pre><code>CREATE DATABASE &lt;数据库名称&gt;;</code></pre><p> 使用数据库(mysql)</p><pre><code>USE &lt;数据库&gt;</code></pre><hr><h2 id="2-表的创建"><a href="#2-表的创建" class="headerlink" title="2 表的创建"></a>2 表的创建</h2><pre><code>CREATE TABLE &lt;表名&gt;(&lt;列名&gt; &lt;数据类型 &lt;该列所需约束&gt;, &lt;列名&gt; &lt;数据类型 &lt;该列所需约束&gt;, &lt;列名&gt; &lt;数据类型 &lt;该列所需约束&gt;, .... &lt;该表的约束1&gt;,&lt;该表的约束2&gt;,....)</code></pre><h3 id="2-1-命名规则"><a href="#2-1-命名规则" class="headerlink" title="2.1 命名规则"></a>2.1 命名规则</h3><ol><li>只能用半角英文字母,数字,下划线(_)作为数据库和表,列的名字</li><li>名称必须以半角英文字母作为开头</li><li>名字不可以重复.即同一个数据库不可以创建两个相同名称的表,在同一个表也不能创建两个名称相同的列</li></ol><h3 id="2-2-数据类型的指定"><a href="#2-2-数据类型的指定" class="headerlink" title="2.2 数据类型的指定"></a>2.2 数据类型的指定</h3><p>四大基本类型: <strong>INTEGER,CHAR,VARCHAR,DATE</strong></p><blockquote><ol><li><strong>INTEGER</strong><br>用来指定存储整数的列的数据类型(数字型),不能存储小数</li></ol></blockquote><blockquote><ol start="2"><li><strong>CHAR</strong><br>CHAR是CHARACTER(字符)的缩写,是用来指定存储字符串的列的数据类型(字符型).可以用CHAR(10),CHAR(100)这样指定存储的字符串的最大长度.当列中的字符串长度达不到最大长度的时候,使用半角空格进行补足.<br>输入字符串数据时候要如 <strong>‘abc’</strong> 用引号括起<br>虽然sql不区分英文大小写,但存储的字符串区分大小写 则’abc’与’ABc’不等价</li></ol></blockquote><blockquote><ol start="3"><li><strong>VARCHAR</strong><br>同CHAR类型一样,VARCHAR型也是用来指定存储字符串的列的数据类型.但当列中的字符串长度达不到最大长度的时候,<strong>不会使用半角空格进行补足</strong>.</li></ol></blockquote><blockquote><ol start="4"><li><strong>DATE</strong><br>用来指定存储日期(年月日)的列的数据类型</li></ol></blockquote><h2 id="2-3-约束设置"><a href="#2-3-约束设置" class="headerlink" title="2.3 约束设置"></a>2.3 约束设置</h2><p>约束是除了数据类型之外,对列中存储的数据进行限制或者追加条件的功能,常用的有:</p><ul><li><strong>NOT BULL</strong></li><li><strong>UNIQUE</strong></li><li><strong>PRIMARY KEY</strong></li><li><strong>FOREIGN KEY</strong></li><li><strong>CHECK</strong></li><li><strong>DEFAULT</strong></li></ul><blockquote><ul><li><strong>NOT NULL</strong><br>NOT NULL 约束强制列不接受 NULL 值。<br>NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</li></ul></blockquote><blockquote><ul><li><strong>UNIQUE</strong><br>UNIQUE 约束唯一标识数据库表中的每条记录。<br>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。<br>PRIMARY KEY 拥有自动定义的 UNIQUE 约束。<br>请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</li></ul></blockquote><blockquote><ul><li><strong>PRIMARY KEY</strong><br>PRIMARY KEY 约束唯一标识数据库表中的每条记录。<br>主键必须包含唯一的值。<br>主键列不能包含 NULL 值。<br>每个表都应该有一个主键，并且每个表只能有一个主键。</li></ul></blockquote><blockquote><ul><li><strong>FOREIGN KEY</strong><br>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。</li></ul></blockquote><blockquote><ul><li><strong>CHECK</strong><br>CHECK 约束用于限制列中的值的范围。<br>如果对单个列定义 CHECK 约束，那么该列只允许特定的值。<br>如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制</li></ul></blockquote><blockquote><ul><li><strong>DEFAULT</strong><br>DEFAULT 约束用于向列中插入默认值。<br>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</li></ul></blockquote><p>##3 表的删除</p><pre><code>DROP TABLE &lt;表名&gt;;</code></pre><p><strong>被删除的表是无法恢复的!!谨慎使用</strong></p><h3 id="4-表的更新"><a href="#4-表的更新" class="headerlink" title="4 表的更新"></a>4 表的更新</h3><p><strong>4.1 添加列</strong></p><pre><code>ALTER TABLE &lt;表名&gt; ADD COLUMN &lt;列的定义&gt;;</code></pre><p><strong>4.2 删除列</strong></p><pre><code>ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;;</code></pre><p>示例</p><pre><code>cd c:\\mysql\binmysql -u root -p  #登录本地数据库CREATE DATABASE shop;  #创建shop数据库USE shop  #使用shop数据库#建立product表CREATE TABLE product(  product_id CHAR(4) NOT NULL,  product_name VARCHAR(100) NOT NULL,  product_type VARCHAR(32) NOT NULL,  sale_price INTEGER,  purchase_price INTEGER,  regist_data DATE,  PRIMARY KEY (product_id));#在product表中加入/删去product_name_pinyin列ALTER TABLE product ADD COLUMN product_name_pinyin VARCHAR(100);ALTER TABLE product DROP COLUMN product_name_pinyin;#在表product填写数据START TRANSACTION;INSERT INTO Product VALUES (&#39;0001&#39;, &#39;T恤&#39; ,&#39;衣服&#39;, 1000, 500, &#39;2009-09-20&#39;);INSERT INTO Product VALUES (&#39;0002&#39;, &#39;打孔器&#39;, &#39;办公用品&#39;, 500, 320, &#39;2009-09-11&#39;);INSERT INTO Product VALUES (&#39;0003&#39;, &#39;运动T恤&#39;, &#39;衣服&#39;, 4000, 2800, NULL);INSERT INTO Product VALUES (&#39;0004&#39;, &#39;菜刀&#39;, &#39;厨房用具&#39;, 3000, 2800, &#39;2009-09-20&#39;);INSERT INTO Product VALUES (&#39;0005&#39;, &#39;高压锅&#39;, &#39;厨房用具&#39;, 6800, 5000, &#39;2009-01-15&#39;);INSERT INTO Product VALUES (&#39;0006&#39;, &#39;叉子&#39;, &#39;厨房用具&#39;, 500, NULL, &#39;2009-09-20&#39;);INSERT INTO Product VALUES (&#39;0007&#39;, &#39;擦菜板&#39;, &#39;厨房用具&#39;, 880, 790, &#39;2008-04-28&#39;);INSERT INTO Product VALUES (&#39;0008&#39;, &#39;圆珠笔&#39;, &#39;办公用品&#39;, 100, NULL, &#39;2009-11-11&#39;);COMMIT;</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql入门(1)--sql了解</title>
      <link href="/2019/12/29/MYSQL/sql%E5%85%A5%E9%97%A8(1)--sql%E4%BA%86%E8%A7%A3/"/>
      <url>/2019/12/29/MYSQL/sql%E5%85%A5%E9%97%A8(1)--sql%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL了解"><a href="#SQL了解" class="headerlink" title="SQL了解"></a>SQL了解</h1><h2 id="1-SQL语句种类"><a href="#1-SQL语句种类" class="headerlink" title="1 SQL语句种类"></a>1 SQL语句种类</h2><p>SQL语言分为DDL,DML,DCL三类</p><ul><li><strong>DDL</strong><br>DDL(Data Definition Language,数据定义语言)用来创建或者删除存储数据用的数据库以及数据库中的表等对象.DDl包含以下几种指令</li></ul><ol><li><strong>CREATE</strong>: 创建数据库和表等对象</li><li><strong>DROP</strong>: 删除数据库和表等对象</li><li><strong>ALTER</strong>: 修改数据库和表等对象的结构</li></ol><hr><ul><li><strong>DML</strong><br>DML(Data Manipulation Language,数据操纵语言)用来查询或者变更表中的记录.DML包含以下指令</li></ul><ol><li><strong>SELECT</strong>: 查询表中的数据</li><li><strong>INSERT</strong>: 向表中插入新数据</li><li><strong>UPDATE</strong>: 更新表中的数据</li><li><strong>DELETE</strong>: 删除表中的数据</li></ol><hr><ul><li><strong>DCL</strong><br>DCL(Data Control Language,数据控制语言)用来确认或取消对数据库中的数据进行的变更.除此之外还可以对用户是否有权限操作数据库中的对象(数据库表等)进行设定.DCL包含以下几种指令</li></ul><ol><li><strong>COMMIT</strong>: 确认对数据库中的数据进行变更</li><li><strong>ROLLBACK</strong>: 取消对数据库中数据进行变更</li><li><strong>GRANT</strong>: 赋予用户操作权限</li><li><strong>REVOKE</strong>: 取消用户操作权限</li></ol><blockquote><p>Note:<br>实际使用的SQL语句当中有90%属于DML,要以DML为中心学习</p></blockquote><hr><hr><h2 id="2-SQL的基本书写规则"><a href="#2-SQL的基本书写规则" class="headerlink" title="2 SQL的基本书写规则"></a>2 SQL的基本书写规则</h2><blockquote><p>Note:</p><ol><li>SQL语句以<strong>分号(\; )</strong> 结尾</li><li>SQL语句不区分关键字的大小写字符串和日期常数需要使用 <strong>单引号(‘ ‘)</strong> 括起来</li><li>数字常数无须加注单引号,直接书写数字即可</li><li>单词之间需要使用半角空格或者换行符进行分隔</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型评估--泛化误差评估</title>
      <link href="/2019/12/25/Machine-Learning/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0--%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86/"/>
      <url>/2019/12/25/Machine-Learning/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0--%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><h2 id="1-误差"><a href="#1-误差" class="headerlink" title="1 误差"></a>1 误差</h2><ul><li><strong>错误率E(error rate)</strong>:分类错误的样本数占总数的比例<br>$$ E=\frac{a}{m} $$<br>其中m为样本总数 a为样本分类错误数量  </li></ul><ul><li><strong>精度A(accuracy)</strong>:分类正确的样本数占总数的比例<br>$$ A = 1- E = 1 - \frac{a}{m}$$<br><br></li></ul><ul><li><strong>误差(error)</strong>:更加一般地,把学习器的实际预测输出与样本的真实输出之间的差异称为误差</li><li><strong>训练误差(training error)</strong>:学习器在训练集上的误差称为训练误差</li><li><strong>泛化误差(training error)</strong>:学习器在新样本上的误差称为泛化误差<br><br><blockquote><p>Note:<br>显然,我们希望得到泛化误差小的学习器,然而,我们实现并不知道新样本是什么样,实际能做的是努力是训练误差最小化</p></blockquote></li></ul><hr><p><br></p><h2 id="2-拟合效果"><a href="#2-拟合效果" class="headerlink" title="2 拟合效果"></a>2 拟合效果</h2><ul><li><strong>过拟合(overfitting)</strong>:学习器把训练样本学得”太好了”,把训练样本自身的一些特点当作了所有现在样本都会有的一般性质,这样会导致泛化性能下降</li><li><strong>欠拟合(underfitting)</strong>:学习器对训练样本的一般性质尚未学好<br><br><blockquote><p>Note:<br>一. 欠拟合一般由于学习能力低下造成的.欠拟合比较容易克服,例如在决策树学习中拓展分支,在神经网络学习中增加训练次数等<br>二.过拟合是机器学习面临的关键障碍.过拟合是无法彻底避免的,我们所能做的只是”缓解”,或者说减少问题.</p></blockquote></li></ul><hr><h2 id="3-泛化误差评估"><a href="#3-泛化误差评估" class="headerlink" title="3 泛化误差评估"></a>3 泛化误差评估</h2><h3 id="3-1-留出法-hold-out"><a href="#3-1-留出法-hold-out" class="headerlink" title="3.1 留出法(hold-out)"></a>3.1 留出法(hold-out)</h3><p>留出法直接将数据集<em>D</em>划分两个互斥的集合,其中一个集合作为训练集<em>S</em>,另一个作为测试集<em>T</em>,则有<br>$$ D=S \cup T$$ $$ S \cap T= \emptyset $$<br><br></p><blockquote><p>Note:<br>1.数据的划分要尽可能保持数据分布的一致性,避免因划分过程引入额外的偏差而对最终结果产生影响.例如在分类任务中至少保持样本的类别比例相似,则<strong>分层抽样</strong><br>2.留出法对<em>D</em>的划分有多种,因此,单次使用留出法得到的估计结果往往不够可靠稳定.一般要采用<strong>若干次随机划分,重复进行实验评估取平均值作为留出法的评估结果</strong></p></blockquote><p><br></p><h3 id="3-2-交叉验证法-cross-validation"><a href="#3-2-交叉验证法-cross-validation" class="headerlink" title="3.2 交叉验证法(cross validation)"></a>3.2 交叉验证法(cross validation)</h3><ul><li>“交叉验证法”(k折交叉验证)先将数据集<em>D</em>划分为k个大小相似的互斥子集,即<br>$$D= D_{1} \cup D_{2} \cup … \cup D_{k}$$ $$D_{i} \cap D_{j}= \emptyset  (i \neq j)$$<br><a href="https://postimg.cc/bDx5Ck9H" target="_blank" rel="noopener"><img src="https://i.postimg.cc/DZHKzcWD/image.png" alt="image.png"></a><blockquote><p>Note:<br>一.每个子集都要尽可能保持数据分布的一致性,即从<em>D</em>中分层抽样<br>二.与留出法相似,将数据集<em>D</em>划分为k个子集同样存在多种划分方法.为减少由于划分引入的偏差,一般将k折交叉验证随机使用不同的划分重复p次,最终评估结果是这p次k折交叉验证结果的均值</p></blockquote></li></ul><p><br></p><ul><li>留一法<br>假定数据集<em>D</em>中包含m个样本,若令k=m,则得到了交叉验证法的一个特例:<strong>留一法</strong><blockquote><p>Note:<br>优点<br>一.留一法不受随机样本划分方式的影响,因为划分方式是唯一的<br>二.留一法中被实际评估的模型与期望评估的用<em>D</em>训练出的模型很相似<br>缺点:计算开销大</p></blockquote></li></ul><p><br></p><h3 id="3-3-自助法Bootstrap"><a href="#3-3-自助法Bootstrap" class="headerlink" title="3.3 自助法Bootstrap"></a>3.3 自助法Bootstrap</h3><p>自助法的基本思想是：给定包含m个样本的数据集D，每次随机从D 中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D 中，使得该样本在下次采样时仍有可能被采到。重复执行m 次，就可以得到了包含m个样本的数据集D’。可以得知在m次采样中，样本始终不被采到的概率取极限为：</p><p>$$\lim_{x\to\infty}(1-\frac{1}m{})^m\to \frac{1}{e}\approx0.368$$<br>这样，通过自助采样，初始样本集D中大约有36.8%的样本没有出现在D’中，于是可以将D’作为训练集，D-D’作为测试集。</p><blockquote><p>Note:<br>1.Bootstrap的本质是放回抽样<br>2.优点:我们希望评估的是用整个D训练出的模型。但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差。留一法受训练样本规模变化的影响较小，但计算复杂度又太高了。“自助法”正是解决了这样的问题。<br>3.缺点:自助法在数据集较小，难以有效划分训练集/测试集时很有用，但由于自助法产生的数据集（随机抽样）改变了初始数据集的分布，因此引入了估计偏差。在初始数据集足够时，留出法和交叉验证法更加常用。</p></blockquote><hr><h2 id="4-验证集"><a href="#4-验证集" class="headerlink" title="4 验证集"></a>4 验证集</h2><ul><li><strong>测试数据</strong>:把学得模型在实际使用中遇到的数据称为测试数据.</li><li><strong>验证集(validation set)</strong>:为了加以区分,模型评估与选择中用于评估测试的数据集常称为”验证集”.<blockquote><p>Note:例如,在研究对比不同算法的泛化性能时,我们用测试集上的判别效果来估计在实际使用时的泛化能力,而把训练数据另外划分为训练集和验证集,基于验证集上的性能来进行模型选择和调参</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 泛化误差 </tag>
            
            <tag> 数据集划分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量化分析文章索引</title>
      <link href="/2019/05/03/Quantitative-Analysis/Quantitative-Analysis_Catalogue/"/>
      <url>/2019/05/03/Quantitative-Analysis/Quantitative-Analysis_Catalogue/</url>
      
        <content type="html"><![CDATA[<ul><li>还没开坑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 量化分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目录 </tag>
            
            <tag> 量化分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化文章索引</title>
      <link href="/2019/05/03/Data-Visualization/Data-Visualization_Catalogue/"/>
      <url>/2019/05/03/Data-Visualization/Data-Visualization_Catalogue/</url>
      
        <content type="html"><![CDATA[<ul><li>还没开坑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目录 </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间序列文章索引</title>
      <link href="/2019/05/03/Time-Series/Time-Series_Catalogue/"/>
      <url>/2019/05/03/Time-Series/Time-Series_Catalogue/</url>
      
        <content type="html"><![CDATA[<ul><li>还没开坑</li></ul><ol><li><p>还没开坑</p></li><li><p>还没开坑</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 时间序列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目录 </tag>
            
            <tag> 时间序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参数统计文章索引</title>
      <link href="/2019/05/03/Parametric-Statistics/Parametric-Statistics_Catalogue/"/>
      <url>/2019/05/03/Parametric-Statistics/Parametric-Statistics_Catalogue/</url>
      
        <content type="html"><![CDATA[<ul><li>还没开坑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 参数统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目录 </tag>
            
            <tag> 参数统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非参数统计文章索引</title>
      <link href="/2019/05/03/Nonparametric-Statistics/Nonparametric-Statistics_Catalogue/"/>
      <url>/2019/05/03/Nonparametric-Statistics/Nonparametric-Statistics_Catalogue/</url>
      
        <content type="html"><![CDATA[<ul><li>还没开坑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 非参数统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目录 </tag>
            
            <tag> 非参数统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习文章索引</title>
      <link href="/2019/05/03/Machine-Learning/Machine-Learning_Catalogue/"/>
      <url>/2019/05/03/Machine-Learning/Machine-Learning_Catalogue/</url>
      
        <content type="html"><![CDATA[<ol><li>模型评估–数据集划分</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回归分析文章索引</title>
      <link href="/2019/05/03/Regression-Analysis/Regression-Analysis_Catalogue/"/>
      <url>/2019/05/03/Regression-Analysis/Regression-Analysis_Catalogue/</url>
      
        <content type="html"><![CDATA[<ul><li>还没开坑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 回归分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目录 </tag>
            
            <tag> 回归分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
